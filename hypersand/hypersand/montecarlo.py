import numpy as np
import pandas as pd
import random
from . import plot
from . import generator
from . import interpfs

"""
Вычисление объема фигуры с помощью метода Монте-Карло.
"""

"""
2D:
1) "Кинуть" случайную точку (x_r, y_r).
2)  I.  1. Построить прямую Ax + C = 0 (параллельную оси Oy).
        2. Найти все точки пересечения прямой с графиком.
        3. Найти максимальную y_max и минимальную y_min среди пересечений.
        4. Если y_min <= y_r <= y_max, то продолжить. Если нет, то нет попадания.
    II. 1. Построить прямую By + C = 0 (параллельную оси Ox).
        2. Найти все точки пересечения прямой с графиком.
        3. Найти максимальную x_max и минимальную x_max среди пересечений.
        4. Если x_min <= x_r <= x_max, то попадание. Если нет, то нет попадания.

3D:
1) "Кинуть" случайную точку (x_r, y_r, z_r).
2)  I.   1. Построить плоскость Ax + D = 0 (параллельную плоскости Oyz).
         2. Найти все точки пересечения плоскости с графиком.
         3. Найти максимальную y_max и минимальную y_min среди пересечений.
         4. Найти максимальную z_max и минимальную z_min среди пересечений.
         5. Если y_min <= y_r <= y_max и z_min <= z_r <= z_max, то продолжить.
            Если нет, то нет попадания.
    II.  1. Построить плоскость By + D = 0 (параллельную плоскости Oxz).
         2. Найти все точки пересечения плоскости с графиком.
         3. Найти максимальную x_max и минимальную x_max среди пересечений.
         4. Найти максимальную z_max и минимальную z_min среди пересечений.
         5. Если x_min <= x_r <= x_max и z_min <= z_r <= z_max, то продолжить.
            Если нет, то нет попадания.
    III. 1. Построить плоскость Cz + D = 0 (параллельную плоскости Oxy).
         2. Найти все точки пересечения плоскости с графиком.
         3. Найти максимальную x_max и минимальную x_max среди пересечений.
         4. Найти максимальную y_max и минимальную y_min среди пересечений.
         5. Если x_min <= x_r <= x_max и y_min <= y_r <= y_max, то попадание.
            Если нет, то нет попадания.

4D:
1) "Кинуть" случайную точку (x_r, y_r, z_r, t_r).
2)  I.   1. Построить гиперплоскость Ax + E = 0 (параллельную гиперплоскости Oyzt).
         2. Найти все точки пересечения гиперплоскости с графиком.
         3. Найти максимальную y_max и минимальную y_min среди пересечений.
         4. Найти максимальную z_max и минимальную z_min среди пересечений.
         5. Найти максимальную t_max и минимальную t_min среди пересечений.
         6. Если y_min <= y_r <= y_max, z_min <= z_r <= z_max и
            t_min <= t_r <= t_max, то продолжить. Если нет, то нет попадания.
    II.  1. Построить гиперплоскость By + E = 0 (параллельную гиперплоскости Oxzt).
         2. Найти все точки пересечения гиперплоскости с графиком.
         3. Найти максимальную x_max и минимальную x_max среди пересечений.
         4. Найти максимальную z_max и минимальную z_min среди пересечений.
         5. Найти максимальную t_max и минимальную t_min среди пересечений.
         6. Если y_min <= y_r <= y_max, z_min <= z_r <= z_max и
            t_min <= t_r <= t_max, то продолжить. Если нет, то нет попадания.
    III. 1. Построить гиперплоскость Cz + E = 0 (параллельную гиперплоскости Oxyt).
         2. Найти все точки пересечения гиперплоскости с графиком.
         3. Найти максимальную x_max и минимальную x_max среди пересечений.
         4. Найти максимальную y_max и минимальную y_min среди пересечений.
         5. Найти максимальную t_max и минимальную t_min среди пересечений.
         6. Если x_min <= x_r <= x_max, y_min <= y_r <= y_max и
            t_min <= t_r <= t_max, то продолжить. Если нет, то нет попадания.
    IV.  1. Построить гиперплоскость Dt + E = 0 (параллельную гиперплоскости Oxyz).
         2. Найти все точки пересечения гиперплоскости с графиком.
         3. Найти максимальную x_max и минимальную x_max среди пересечений.
         4. Найти максимальную y_max и минимальную y_min среди пересечений.
         5. Найти максимальную z_max и минимальную z_min среди пересечений.
         6. Если x_min <= x_r <= x_max, y_min <= y_r <= y_max и
            z_min <= z_r <= z_max, то продолжить. Если нет, то нет попадания.
"""

def throw_points(data, number):
    """
    Генерация случайных точек для заданных данных в зависимости от размерности.

    Параметры:
        data - таблица с данными. Данные могут быть произвольной размерности.
    Тип - pandas.DataFrame.
        number - количество генерируемых точек. Тип - int.

    Возвращает сгенерированные точки. Тип - pandas.DataFrame.
    """
    points = pd.DataFrame()
    # Для каждого столбца генерируем number случайных чисел. В итоге получится
    # number случайных точек (все точки в одной строке формируют координаты
    # одной точки).
    for key in data.keys():
        column = []
        for i in range(number):
            # По каждой оси формируется случайное значение между минимальным и
            # максимальным на этой оси
            column.append(random.uniform(data[key].min(), data[key].max()))
        points[key] = column
    return points

def n_throw_points(data, number):
    """
    (DERPECATED)
    Генерация случайных точек для заданных данных в зависимости от размерности.

    Параметры:
        data - таблица с данными. Данные могут быть произвольной размерности.
    Тип - pandas.DataFrame.
        number - количество генерируемых точек. Тип - int.

    Возвращает сгенерированные точки. Тип - pandas.DataFrame.
    """
    points = pd.DataFrame()
    for i in range(number):
        row = pd.DataFrame(index=data.keys())
        for key in data.keys():
            row[key] = random.uniform(data[key].min(), data[key].max())
        points = points.append(row)
    return points

def get_intersections(data, point, precision):
    """
    Получение всех пересечения точки по каждой координате с графиком в фазовой
    плоскости.

    Параметры:
        data - таблица с данными. Данные могут быть произвольной размерности.
    Тип - pandas.DataFrame.
        point - точка, для которой получаются пересечения.
    Тип - pandas.DataFrame.
        precision - точность, с которой считаются пересечения. По всем осям
    строятся гиперплоскости с шириной precision. Если точка графика пересекает
    гиперплоскость, то она является точкой пересечения (если точка графика
    попадает в окружность радиуса precision, то эта точка засчитывается как
    точка пересечения). Тип - float.

    Возвращает таблицу из точек пересечения. Тип - pandas.DataFrame.
    """
    intersections = []
    ifs = interpfs.get_interpfs(data)
    # Строится гиперплоскость Ax + D = 0 (hyper_key = "x")
    # Т.е. идет перебор значений каждого столбца data[key] кроме data[hyper_key]
    for key in data.keys():
        times = [] # Времена пересечений [t1, t2, t3...]
        # Интерполяция графиков и поиск пересечений гиперплоскости с графиком
        # с точностью precision
        for i in data.index:
            if np.fabs(point[key] - ifs[key](i)) <= precision:
                # Добавляются времена для точек пересечения
                times.append(i)
        if len(times) > 0:
            # По временам восстанавливаются точки пересечений
            for time in times:
                intersection = [] # Точки пересечения [x, y, z...]
                for add_key in data.keys():
                    intersection.append(ifs[add_key](time))
                intersections.append(intersection)
    result = pd.DataFrame(intersections, columns=data.keys())
    return result

def is_hit(intersections, point, key, precision):
    """
    Определение, попала ли (одна!) координата точки внутрь фигуры.

    Параметры:
        intersections - таблица из точек пересечения. Тип - pandas.DataFrame.
        point - точка, для которой определяется факт попадания.
    Тип - pandas.DataFrame.
        key - название столбца (оси), для которой определяется факт попадания.
    Тип - str.
        precision - точность, с которой определяется факт попадания. Если
    координата точки point попадает в окружность радиуса precision, то для этой
    координаты засчитывается попадание. Тип - float.

    Возвращает результат попадания. Тип - bool.
    """
    # Поиск максимального и минимального значения по заданной координате key
    # Индексы
    imax = intersections[key].astype('float64').idxmax()
    imin = intersections[key].astype('float64').idxmin()
    # Значения
    vmax = intersections.iloc[imax][key]
    vmin = intersections.iloc[imin][key]
    # Если координата точки меньше чем минимальное значение графика на заданной
    # оси key, или больше, чем максимальное, то координата не попала в объем.
    # (с учетом радиуса precision).
    return not (vmax < point[key] + precision or vmin > point[key] - precision)

def hit_analysis(data, rp, precision):
    """
    Определение точек, которые попали и не попали внутрь фигуры.

    Параметры:
        data - таблица с данными. Данные могут быть произвольной размерности.
    Тип - pandas.DataFrame.
        rp - список из случайных точек, для которых определяется факт попадания.
    Тип - list.
        precision - точность, с которой определяется факт попадания. Если
    координата точки point попадает в окружность радиуса precision, то для этой
    координаты засчитывается попадание. Тип - float.

    Возвращает список из двух таблиц (pandas.DataFrame) - точек, которые попали
    и не попали внутрь фигуры. Тип - list.
    """
    keys = data.keys()
    hits = pd.DataFrame(columns=data.keys())
    misses = pd.DataFrame(columns=data.keys())
    # Определение попадания
    # Перебор всех случайно сгенерированных точек
    for i in range(len(rp)):
        flag = True # Флаг попаданий
        # Получение всех пересечений по одной оси
        intersections = get_intersections(data, rp.iloc[i], precision)
        for key in keys:
            # Сравнение значения с экстремумами по каждой оси, кроме той,
            # по которой получались пересечения
            if not is_hit(intersections, rp.iloc[i], key, precision * 2):
                flag = False
        # Если попадание было зафиксировано, то добавляем точку в попадания
        if flag:
            hits = hits.append(rp.iloc[i])
        # Если попадание не было зафиксировано, то добавляем точку в промахи
        else:
            misses = misses.append(rp.iloc[i])
    return [hits, misses]

def cuboid_volume(data):
    """
    Вычисление объема n-мерного кубоида.

    Параметры:
        data - таблица с данными. Данные могут быть произвольной размерности.
    Тип - pandas.DataFrame.

    Возвращает объем кубоида. Тип - float.
    """
    volume = 1
    for key in data.keys():
        # По каждой оси вычисляется длина одной из сторон кубоида
        size = np.fabs(data[key].min() - data[key].max())
        # Объем кубоида - произведение длин всех сторон
        volume *= size
    return volume

def montecarlo(data, rp, precision):
    """
    Вычисление объема фигуры с помощью геометрического определения вероятности.
    P = n / m, где P - вероятность попадания, n - количество точек, которые
    попали внутрь кубоида, m - общее количество точек. V = Vk * P, где V -
    объем фигуры, Vk - объем кубоида.
    Объем фигуры = Объем кубоида * Количество попаданий / Все точки

    Параметры:
        data - таблица с данными. Данные могут быть произвольной размерности.
    Тип - pandas.DataFrame.
        rp - список из случайных точек, для которых определяется факт попадания.
    Тип - list.
        precision - точность, с которой определяется факт попадания. Если
    координата точки point попадает в окружность радиуса precision, то для этой
    координаты засчитывается попадание. Тип - float.

    Возвращает объем фигуры. Тип - float.
    """
    # Получение объема n-мерного кубоида
    volume = cuboid_volume(data)
    # Определение точек, которые попали и не попали внутрь фигуры.
    [hits, misses] = hit_analysis(data, rp, precision)
    # Объем фигуры = Объем кубоида * Количество попаданий / Все точки
    return volume * len(hits) / len(rp)
